# 문제

라그랑주는 1770년에 모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있다고 증명하였다. 

어떤 자연수는 복수의 방법으로 표현된다. 

예를 들면, 26은 52과 12의 합이다; 

또한 42 + 32 + 12으로 표현할 수도 있다. 

역사적으로 암산의 명수들에게 공통적으로 주어지는 문제가 바로 자연수를 넷 혹은 그 이하의 제곱수 합으로 나타내라는 것이었다. 

1900년대 초반에 한 암산가가 15663 = 1252 + 62 + 12 + 12라는 해를 구하는데 8초가 걸렸다는 보고가 있다. 

좀 더 어려운 문제에 대해서는 56초가 걸렸다: 11339 = 1052 + 152 + 82 + 52.

자연수 n이 주어질 때, n을 최소 개수의 제곱수 합으로 표현하는 컴퓨터 프로그램을 작성하시오.

https://www.acmicpc.net/problem/17626

## 문제 분류

다이나믹 프로그래밍

## 입출력 예시

<table>
  <tr>
    <th>입력</th>
    <th>출력</th>
  </tr>
  <tr>
    <td>25<br>26<br>11339<br>34567</td>
    <td>1<br>2<br>3<br>4</td>
  </tr>
</table>

# 풀이

DP 문제이다.

단순히 for문을 돌리면 n^2으로 시간 초과가 난다.

그렇다고 해서 dp[i]+dp[n-i]의 식에서 i가 n-i까지로 범위 설정해도 그대로 n^2/2로 시간 초과다.

n의 범위가 50000이기 때문에 제곱수를 활용해서 풀어야 한다.

## 나는 ..

제일 가까운 제곱수를 이용해서 문제를 푸려고 했으나 꼭 최근 제곱수가 해당하는 정답의 자연수가 아닐 수 있다는 것을 알았다.

그렇다면 어떻게 해야 할까.

나는 풀던대로 또 배열을 이용해서 푸려고 했다.

그러나 C++로 푸는 만큼 vector를 이용하는 습관을 들여야겠다.

먼저 vector에 제곱수를 넣어준다.

그리고 n까지 돌며 vector를 둘러보면서 DP를 활용하자.

그러면 vector의 크기가 224인 것을 이용하면 n*224 = 50000*224 = 1억 즈음이므로 시간 제한에 걸리지 않는다.

또 각각 MAX 값으로 dp[i]를 설정할 필요 없이 vector를 둘러보기 전 MIN을 MAX로 설정한다.

만약 i가 v[i]와 같다면 제곱수이므로 MIN을 0으로 설정하고, 아니라면 MIN을 해당 제곱수를 선택했을 때 square[i-v[j]]값과 비교해서 작은 값을 넣어준다.

이유는 설명하지 않아도 알겠지만 square[i]는 제곱수이므로 1일테고 이는 최종적으로 더해줄 것이므로 square[i-v[j]] 값만 비교해준다.

벡터를 자주 사용하자!