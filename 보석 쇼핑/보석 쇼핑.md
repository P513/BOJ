# 문제

[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다.

어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.

어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.

< 진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매 >

예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.

진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.

진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.

진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 

이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.


가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다.

https://programmers.co.kr/learn/courses/30/lessons/67258

## 문제 분류

2020 카카오 인턴십

## 제한사항

gems 배열의 크기는 1 이상 100,000 이하입니다.

gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.

gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.

gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.

## 입출력 예시

<table>
  <tr>
    <th>gems</th>
    <th>result</th>
  </tr>
  <tr>
    <td>["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]</td>
    <td>[3, 7]</td>
  </tr>
  <tr>
    <td>["AA", "AB", "AC", "AA", "AC"]</td>
    <td>[1, 3]</td>
  </tr>
  <tr>
    <td>["XYZ", "XYZ", "XYZ"]</td>
    <td>[1, 1]</td>
  <tr>
    <td>["ZZZ", "YYY", "NNNN", "YYY", "BBB"]</td>
    <td>[1, 5]</td>
  </tr>
  </tr>
</table>

## 풀이

먼저 보석을 처음부터 종류별로 다 담을 때까지 담는다.

첫 번째 인덱스를 시작으로 끝까지 다 담았을 때 마지막 인덱스, 각각을 answer로 설정한다.

이 때 마지막 인덱스와 처음 인덱스의 거리를 최소 거리로 설정한다.

앞의 보석 하나씩 포기한다! 이 때 포기한 보석이 내가 가지고 있는 바구니에 없다면 마지막 인덱스 뒤에 그 보석이 있는지 확인한다.

만약 있다면 다시 그 보석을 담고 최소 거리와 비교해서 값을 갱신한다.

만약 해당하는 보석이 진열대 끝까지 존재하지 않는다면 처음 설정한 값이 답이 된다.

## 나는 ..

일단 이 문제는 푸는 것도 중요하고 효율도 꽤 중요하다.

그래서 하루 종일 잡고 풀었지만 답이 나오지 않았다.

이 문제를 풀기 위해 슬라이딩 윈도우, two 포인터가 필요하다.

슬라이딩 윈도우는 사이즈가 정해져 있어 이 문제에 적합하지 않고 two 포인터를 사용하는게 좋다.

그리고 주어지는 보물들의 종류를 찾기 위해 나는 삽질을 했다.

vector의 중복 제거 방식을

```
sort(v.begin(), v.end());
v.erase(unique(v.begin(), v.end()), v.end());
```

위와 같이 짰는데 이는 set를 사용하면 쉽게 해결된다.

### set

set은 map과 달리 key만 존재하고 value는 존재하지 않는다.

또한 객체 중복을 허용하지 않는다.

보석의 종류를 구하기에 좋다.

vector "크기"는 length 가 아니라 size이다.

만약 map<string, int> map의 출력을 원한다면,

```
map<string, int>::iterator iter;
for(iter=map.begin(); iter!=map.end(); iter++){
	printf("%s %d\n", iter->first, iter->second);
}
```

위와 같이 구현하거나, 아래와 같이 구현하자.

```
for(auto iter:map){
	printf("%s %d\n", iter.first, iter.second);
}
```

### unordered_map과 unordered_set

unordered_map, unordered_set은 해시 함수를 사용한다.

삽입과 탐색에 걸리는 시간 복잡도가 O(1)로 상수 시간이다.

최악은 O(N)이고 이 때, N은 원소 개수이다.

그러나 그냥 map과 set은 최악과 최적이 모두 O(log n)이다.

따라서 최적화가 필요한 이 문제에서 unordered_map을 사용했다.

하지만 평소에는 그냥 map을 사용하자.

### auto&를 사용한 이유

auto i:v를 사용할 경우 값이 계속 복사된다.

그러나 참조자를 사용하면 복사 대신 그 값을 참조하므로 복사하는 비효율성이 줄어든다.
