# C++이란

C++은 기존의 C언어에 여러 기능을 추가하여 만든 프로그래밍 언어다.

C++은 C언어에서 절차 지향적 언어의 특징을 가져왔을 뿐만 아니라, 클래스를 사용하는 객체 지향적 언어인 동시에 템플릿으로 대변되는 일반화 프로그래밍 방식의 언어다.

C++은 C언어가 개발된 벨 연구소의 비야네 스트롭스트룹(Bjarne Stroustrup)에 의해 개발되었다.

## 네임스페이스(namespace)

네임스페이스란 이름이 기억되는 영역을 의미하며, 이름이 소속된 공간을 의미한다.

네임스페이스는 C++ 프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해주는 방법을 제공한다.

이런 네임스페이스는 C언어에 없는 C++ 만의 기능이다.

## iostream 

사용자가 프로그램과 대화하기 위해서는 사용자와 프로그램 사이의 입출력을 담당하는 수단이 필요하다.

C++의 모든 것은 객체로 표현되므로, 입출력을 담당하는 수단 또한 C언어의 함수와는 달리 모두 객체다.

C언어의 printf() 함수나 scanf() 함수처럼 C++에서도 iostream 헤더 파일에 표준 입출력 클래스를 정의하고 있다.

## 실수의 표현 방식

1. 고정 소수점(fixed point) 방식

실수는 보통 정수부와 소수부로 나눌 수 있다.

따라서 실수를 표현하는 가장 간단한 방식은 소수부의 자릿수를 미리 정해 고정된 자릿수의 소수를 표현하는 것이다.

32bits의 경우 1bit는 부호, 15bit는 정수부, 16bit는 소수부로 나눈다.

하지만 이 방식은 정수부와 소수부의 자릿수가 크지 않아 표현할 수 있는 범위가 매우 적다.

2. 부동 소수점(floating point) 방식

실수는 보통 정수부와 소수부로 나누지만, 가수부와 지수부로 나누어 표현할 수도 있다.

부동 소수점 방식은 이렇게 하나의 실수를 가수부와 지수부로 나누어 표현하는 방식이다.

(부호)(1.가수부)X2^(지수부-127)

대부분의 시스템에서는 부동 소수점 방식을 이용해 실수를 표현한다.

## C언어 스타일의 문자열

C++ 문자열

문자열이란 메모리에 저장된 일련의 연속된 문자들의 집합이다.

C++에서는 이런 문자열을 두 가지 방법으로 생성한다.

1. C언어 스타일의 문자열

C++에서는 큰 따옴표를 사용해 표현되는 문자열을 문자열 상수라고 한다.

C++에서 문자형 배열을 선언하면 이 배열이 곧 문자열 변수가 된다.

2. string 클래스를 이용한 문자열

## String 메소드

- length() 메소드

문자열의 길이를 나타낸다.

-size() 메소드

해당 string 객체가 메모리에서 실제 사용하고 있는 크기를 나타낸다.

- append() 메소드

하나의 문자열의 끝에 다른 문자열을 추가하는 메소드다.

1. 문자열.append(추가할문자열);                 // 추가할 문자열을 맨 끝에 추가함.

2. 문자열.append(추가할문자열, 시작위치, 개수); // 추가할 문자열의 시작 위치부터 개수만큼만 맨 끝에 추가함.

3. 문자열.append(개수, 추가할문자);             // 추가할 문자를 개수만큼 맨 끝에 추가함

- find() 메소드

특정 문자열을 찾아, 그 시작 위치를 반환하는 메소드다.

1. 문자열.find(찾을문자열);           // 인덱스 0부터 찾을 문자열을 찾아, 그 시작 위치를 반환함.

2. 문자열.find(찾을문자);             // 인덱스 0부터 찾을 문자를 찾아, 그 시작 위치를 반환함.

3. 문자열.find(찾을문자열, 시작위치); // 시작 위치부터 찾을 문자열을 찾아, 그 시작 위치를 반환함.

find() 메소드는 해당 문자열에서 찾을 문자열을 찾지 못하면, string::size_type의 string::npos라는 상수를 반환한다.

- compare() 메소드

두 문자열 간의 내용을 비교하는 메소드다.

1. str1.compare(str_02) == 0 // str1과 str2이 같을 경우

2. str1.compare(str_02) < 0  // str1이 str2보다 사전 편찬순으로 앞에 있을 경우

3. str1.compare(str_02) > 0  // str1이 str2보다 사전 편찬순으로 뒤에 있을 경우

- replace() 메소드

특정 문자열을 찾아, 그 문자열을 다른 문자열로 대체한다.

문자열.replace(대체할문자열의시작위치, 대체할문자열의길이, 새로운문자열);

// 전달된 시작 위치부터 문자열의 길이만큼을 제거한 후에, 새로운 문자열을 삽입함.

## 함수 포인터(function pointer)

프로그램에서 정의된 함수는 프로그램이 실행될 때 모두 메인 메모리에 올라간다.

이때 함수의 이름은 메모리에 올라간 함수의 시작 주소를 가리키는 포인터 상수가 된다.

함수 시작 주소를 가리키는 포인터 상수를 함수 포인터라고 한다.

void Func(int, int); 을 void (*ptr_func)(int, int);로 선언한다.

```
    double Add(double, double);

    double Sub(double, double);

    double Mul(double, double);

    double Div(double, double);
    
    double (*calc)(double, double) = NULL; // 함수 포인터 선언

    calc = Mul; 이런식으로 나타낸다.
```

## 참조자

C++에서는 특정 변수의 실제 이름 대신 사용할 수 있는 참조자(reference)라는 새로운 기능이 추가되었다.

이러한 참조자는 크기가 큰 구조체와 같은 데이터를 함수의 인수로 전달해야 할 경우에 사용할 수 있다.

또한, C++의 클래스(class)를 설계할 때에도 자주 쓰인다.

int 변수이름;               // 변수의 선언

int& 참조자이름 = 변수이름; // 참조자 선언

주의사항은 아래와 같다.

1. 참조자의 타입은 대상이 되는 변수의 타입과 일치해야 한다.

2. 참조자는 선언과 동시에 초기화되어야 한다.

3. 참조자는 한 번 초기화되면, 참조하는 대상을 변경할 수 없다.

포인터를 사용하는 방법과 참조자를 사용하는 방법 모두 결과는 같으며, 구문 형태상의 차이점만이 존재한다.

C++에서 참조자는 크기가 큰 구조체나 클래스를 다룰 때에만 사용하는 것이 좋다.

## 디폴트 인수

C++에서 새롭게 정의된 디폴트 인수(default argument)는 기본값이 미리 정의되어 있는 인수를 의미한다.

함수를 호출할 때 인수를 전달하지 않으면, 함수는 자동으로 미리 정의되어 있는 디폴트 인수값을 사용하게 된다.

물론 인수를 전달하여 함수를 호출하면, 디폴트 인수값이 아닌 전달된 인수를 가지고 함수를 호출하게 된다.

주의사항은 아래와 같다.

1. 디폴트 인수는 함수의 원형에만 지정할 수 있다.

2. 디폴트 인수는 가장 오른쪽부터 시작하여 순서대로만 지정할 수 있다.

3. 가운데 인수들만 별도로 디폴트 인수를 지정할 수는 없다.

예시

1. void Display(int x, int y, char ch, int z = 4);       // 가능함.

2. void Display(int x, int y, char ch = 'a', int z = 4); // 가능함.

3. void Display(int x, int y = 2, char ch, int z = 4);   // 오류

4. void Display(int x = 1, int y = 2, char ch, int z);   // 오류

## 함수 오버로딩(function overloading)

디폴트 인수가 인수의 개수를 달리하여 같은 함수를 호출하는 것이라면, 함수 오버로딩(overloading)은 같은 이름의 함수를 중복하여 정의하는 것을 의미한다.

함수 오버로딩이란 같은 일을 처리하는 함수를 매개변수의 형식을 조금씩 달리하여, 하나의 이름으로 작성할 수 있게 해주는 것이다.

함수 오버로딩은 객체 지향 프로그래밍의 특징 중 바로 다형성(polymorphism)의 구현이다.

함수 오버로딩의 핵심은 바로 함수 시그니처(function signature)에 있다.

함수 시그니처란 함수의 원형에 명시되는 매개변수 리스트를 가리킨다.

## 인라인 함수

함수가 호출되면 우선 스택에 함수로 전달할 매개변수와 함께 호출이 끝난 뒤 돌아갈 반환 주소값을 저장하게 된다.

그리고서 프로그램의 제어가 함수의 위치로 넘어와 함수 내에 선언된 지역 변수도 스택에 저장한다.

그때부터 함수의 모든 코드를 실행하게 되고, 실행이 전부 끝나면 반환값을 넘겨 준다.

그 후 프로그램의 제어는 스택에 저장된 돌아갈 반환 주소값으로 이동하여, 스택에 저장된 함수 호출 정보를 제거한다.

이와 같은 일련의 함수 호출 과정이 함수마다 일어나게 된다.

함수의 실행 시간이 매우 짧다면, 함수 호출에 걸리는 시간도 부담이 될 수 있다.

C++에서는 이러한 경우에 사용할 수 있는 인라인 함수(inline function)라는 것을 제공한다.

인라인 함수는 호출될 때 일반적인 함수의 호출 과정을 거치지 않고, 함수의 모든 코드를 호출된 자리에 바로 삽입하는 방식의 함수다.

코드가 매우 적은 함수만을 인라인 함수로 선언하는 것이 좋다.

```
inline 함수의원형

또는

inline 함수의정의
```

inline 키워드는 함수의 원형이나 함수의 정의 어느 한 쪽에만 표기해도 되며, 양쪽 다 표기해도 상관없다.

예시는 아래와 같다.

```
inline int Sub(int x, int y){return x-y;}

int main(){
    int a=2, b=3;
    int result = Sub(a,b);
    return 0;
}
```

인라인 함수에서는 재귀 호출이 허용되지 않는다.

## 매크로 함수

C언어에서는 C++의 인라인 함수와 비슷한 기능의 매크로 함수(macro function)를 사용한다.

매크로 함수는 일반 함수와는 달리 단순 치환만을 해주므로, 일반 함수와 똑같은 방식으로 동작하지 않는다.

매크로 함수를 일반 함수처럼 사용하기 위해서는 모든 인수를 괄호({})로 감싸야만한다.

하지만 C++의 인라인 함수는 단순 치환이 아닌 함수의 모든 코드를 호출된 자리에 인라인 코드로 삽입해 주는 것이다.

## 유효 범위(scope)

유효 범위(scope)란 하나의 변환 단위(translation unit) 내에서 해당 변수가 사용될 수 있는 범위를 나타낸다.

함수 내에서 선언된 변수는 함수 내에서만 사용할 수 있다.

## 컨테이너

STL에서 컨테이너(container)는 같은 타입의 여러 객체를 저장하는 일종의 집합이라 할 수 있다.

컨테이너는 클래스 템플릿으로, 컨테이너 변수를 선언할 때 컨테이너에 포함할 요소의 타입을 명시할 수 있다.

1. 시퀀스 컨테이너(sequence container)

시퀀스 컨테이너(sequence container)는 데이터를 선형으로 저장하며, 특별한 제약이나 규칙이 없는 가장 일반적인 컨테이너다.

시퀀스 컨테이너에서는 삽입된 요소의 순서가 그대로 유지된다.

시퀀스 컨테이너의 규칙

a. 모든 요소가 직선 순서대로 배치되어 있어야 한다.

b. 반복자가 최소한 순방향 반복자(forward iterator) 이상이어야 한다.

이것은 반복자가 이동할 때마다 요소들의 순서가 변하지 않음을 보장해 주는 것이다.

c. 시퀀스 컨테이너의 요소들은 명확한 순서를 가지므로, 특정 위치를 참조하는 연산이 가능해야 한다.

해당하는 시퀀스 컨테이너의 종류에는 vector, deque, list, forward_list 가 있다.

- vector

벡터(vector) 컨테이너는 동적 배열의 클래스 템플릿 표현이라 할 수 있다.

벡터(vector) 객체는 요소가 추가되거나 삭제될 때마다 자동으로 메모리를 재할당하여 크기를 동적으로 변경한다.

- deque

데큐(deque) 컨테이너는 double-ended queue를 의미하며, 양쪽에 끝이 있는 큐(queue)다.

이 컨테이너는 컨테이너의 양 끝에서 빠르게 요소를 삽입하거나 삭제할 수 있다.

데큐(deque) 객체는 벡터 객체와 마찬가지로 임의 접근과 동적 크기의 장점을 가지며, 벡터로는 할 수 없는 전방 삽입과 전방 삭제도 빠르게 수행할 수 있다.

deque <int> dq ={20};

dq.push_front(), dq.front(), dq.pop_front(), dq.push_back() 등이 있다.

- list

리스트(list) 컨테이너는 이중 연결 리스트(doubly linked list)의 클래스 템플릿 표현이라 할 수 있다.

이 컨테이너는 컨테이너의 모든 요소에서 양방향 접근, 빠른 삽입과 삭제를 할 수 있지만, 임의 접근은 할 수는 없다.

swap(), reverse(), sort(), unique(), merge(), splice() 등이 있다.

2. 연관 컨테이너(associative container)

연관 컨테이너(associate container)는 키(key)와 값(value)처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너다.

키와 값을 이용한 연관 컨테이너는 요소들에 대한 빠른 접근을 제공해 준다.

하지만 연관 컨테이너는 삽입되는 요소의 위치를 지정할 수는 없다.

이러한 연관 컨테이너는 보통 균형 잡힌 이진 탐색 트리(balanced binary search tree)나 해시 테이블(hash table)을 이용하여 구현한다.

- set

집합(set) 컨테이너는 저장하는 데이터 그 자체를 키로 사용하는 가장 단순한 연관 컨테이너다.

이 컨테이너는 벡터와 달리 오름차순으로 정렬된 위치에 요소를 삽입하므로 검색 속도가 매우 빠르다.

집합(set)에서 키는 유일해야 하므로, 키의 중복을 허용하지 않는다.

set<int> s;

s.insert(20); s.erase(30);

- multiset

멀티집합(multiset)은 키의 중복을 허용하므로, 같은 값을 여러 번 저장할 수 있다.

- map

맵(map) 컨테이너는 키와 값의 쌍으로 데이터를 관리하는 진정한 연관 컨테이너다.

집합 컨테이너와 마찬가지로 정렬된 위치에 요소를 삽입하므로 검색 속도가 매우 빠르다.

맵(map)에서 키는 유일해야 하므로, 키의 중복을 허용하지 않는다.

- multimap

멀티맵(multimap)은 값의 중복을 허용하므로, 하나의 키가 여러 개의 값과 연결될 수 있

- 순서가 지정되지 않은 연관 컨테이너

순서가 지정되지 않은(unordered) 연관 컨테이너는 순서가 지정된 기존의 연관 컨테이너와 같은 동작을 한다.

기존의 연관 컨테이너는 트리(tree) 구조를 기반으로 동작하지만, C++11부터 추가된 이 컨테이너는 해시 테이블(hash table)을 기반으로 동작하게 된다.

따라서 요소의 추가, 삭제 속도가 빨라졌으며, 다양한 검색 알고리즘을 사용할 수 있게 되었다.

순서가 지정된 연관 컨테이너는 양방향 반복자를 지원하지만, 이 컨테이너는 순방향 반복자만을 지원한다.

- unordered_set

- unordered_multiset

- unordered_map

- unordered_multimap

3. 컨테이너 어댑터(adapter container)

컨테이너 어댑터(container adapter)란 기존 컨테이너의 인터페이스를 제한하여 만든 기능이 제한되거나 변형된 컨테이너를 의미한다.

이러한 컨테이너 어댑터는 각각의 기초가 되는 클래스의 인터페이스를 제한하여, 특정 형태의 동작만을 수행하도록 한다.

반복자를 지원하지 않으므로 STL 알고리즘에서는 사용할 수 없다.

- stack

스택(stack) 컨테이너는 vector 클래스의 인터페이스를 제한하여, 전형적인 스택 메모리 구조의 인터페이스를 제공한다.

스택 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱을 따르는 자료 구조다.

s.empyt(), size(), top(), push(), pop() 등이 있다.

- queue

큐(queue) 컨테이너는 deque 클래스의 인터페이스를 제한하여, 전형적인 큐 메모리 구조의 인터페이스를 제공한다.

큐 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 선입선출(FIFO)의 시멘틱을 따르는 자료 구조다.

- priority_queue

우선순위 큐(priority_queue) 컨테이너는 큐와는 달리 큐의 맨 앞의 요소로 가장 먼저 저장된 요소가 아닌, 가장 큰 값을 지닌 요소가 위치하게 된다.

큐가 deque 클래스를 기반으로 하는 것과는 달리, 우선순위 큐는 vector 클래스를 기반으로 한다.



http://tcpschool.com/cpp/cpp_class_intro

http://tcpschool.com/cpp/cpp_algorithm_functor
