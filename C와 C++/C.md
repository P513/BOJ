# C언어란

C언어는 현재 사용하고 있는 거의 모든 컴퓨터 시스템에서 사용할 수 있는 프로그래밍 언어다.

프로그래밍 언어란 컴퓨터의 시스템을 구동시키는 소프트웨어를 작성하기 위한 언어다.

프로그래밍 언어는 저급 언어와 고급 언어로 나뉜다.

저급 언어는 기계가 이해하기 쉽고, 고급 언어는 사람이 이해하기 쉽다.

저급 언어에는 기계어와 어셈블리어가 있다.

실행 속도는 매우 빠르나 사람이 배우기는 매우 어려워 유지 보수가 힘들다.

고급 언어는 컴파일러나 인터프리터에 의해 기계가 이해할 수 있는 언어로 번역되어 실행된다.

대표적으로 자바(컴파일 언어)나 파이썬(인터프리터 언어), C(컴파일 언어), C++(컴파일 언어) 등이 있다.

C언어는 저급 언어와 고급 언어의 특징을 모두 가지고 있는 절차 지향 프로그래밍 언어다.

C언어는 1972년 벨 연구소의 켄 톰프슨과 데니스 리치가 유닉스 운영체제에서 사용하기 위해 개발한 범용적인 고급 언어다.

C언어 이전 유닉스 운영체제는 어셈블리어라는 저급 언어를 사용했다.

하지만 어셈블리어는 특정 하드웨어에 종속적이다.

하나의 기능을 하는 프로그램을 CPU 종류만큼 작성해야 해서 이식성 좋고 쉬운 언어인 C언어가 개발됐다.

## C언어의 특징

1. C언어로 작성된 프로그램은 다양한 하드웨어로의 이식성이 좋다.

2. C언어는 절차 지향 프로그래밍 언어로, 코드가 복잡하지 않아 상대적으로 유지보수가 쉽다.

3. C언어는 저급 언어의 특징을 가지고 있으므로, 어셈블리어 수준으로 하드웨어를 제어할 수 있다.

4. C언어는 코드가 간결하여, 완성된 프로그램의 크기가 작고 실행 속도가 빠르다.


## C언어의 단점

1. C언어는 저급 언어의 특징을 가지고 있으므로, 자바와 같은 다른 고급 언어보다 배우기가 쉽지 않다.

2. C언어는 다른 언어와는 달리 시스템 자원을 직접 제어할 수 있으므로, 프로그래밍하는데 세심한 주의를 기울여야 한다.

## C 프로그래밍 과정

프로그래밍이란 목적에 맞는 알고리즘으로부터 프로그래밍 언어를 사용하여 구체적인 프로그램을 작성하는 과정을 의미한다.

이렇게 작성된 프로그램은 먼저 실행 파일로 변환되어야 실행할 수 있다.

1. 소스 파일(source file)의 작성

프로그래밍에서 가장 먼저 해야 할 작업은 바로 프로그램을 작성하는 것이다.

C언어를 사용하여 문법에 맞게 논리적으로 작성된 프로그램을 원시 파일 또는 소스 파일이라고 한다.

C언어를 통해 작성된 소스 파일의 확장자는 .c 가 된다.

2. 선행처리기(preprocessor)에 의한 선행처리

선행처리(preprocess)란 소스 파일 중에서도 선행처리 문자(#)로 시작하는 선행처리 지시문의 처리 작업을 의미한다.

이러한 선행처리 작업은 선행처리기(preprocessor)가 수행한다.

선행처리기는 코드를 생성하는 것이 아닌, 컴파일하기 전 컴파일러가 작업하기 좋도록 소스를 재구성해주는 역할만을 한다.

3. 컴파일러(compiler)에 의한 컴파일

소스 파일을 컴퓨터가 알아볼 수 있는 기계어로 변환시켜야 하는데, 그 작업을 컴파일(compile)이라고 한다.

컴파일은 컴파일러에 의해 수행되며, 컴파일이 끝나 기계어로 변환된 파일을 오브젝트 파일(object file)이라고 한다.

이러한 오브젝트 파일의 확장자는 .o 나 .obj 가 된다.

4. 링커(linker)에 의한 링크

컴파일러에 의해 생성된 오브젝트 파일은 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)를 가지고 있지 않다.

또한, 대부분의 C 프로그램에서 사용하는 C 표준 라이브러리 파일도 포함되어 있지 않다.

이때 하나 이상의 오브젝트 파일과 라이브러리 파일, 시동 코드 등을 합쳐 하나의 파일로 만드는 작업을 링크(link)라고 한다.

링크는 링커(linker)에 의해 수행되며, 링크가 끝나면 하나의 새로운 실행 파일이나 라이브러리 파일이 생성된다.

이처럼 여러 개의 소스 파일을 작성하여 최종적으로 링크를 통해 하나의 실행 파일로 만드는 것을 분할 컴파일이라고 한다.
 
5. 실행 파일(executable file)의 생성

소스 파일은 선행처리기, 컴파일러 그리고 링커에 의해 위와 같은 과정을 거쳐 실행 파일로 변환된다.

최근 사용되는 개발 툴은 대부분 위에서 소개한 선행처리기, 컴파일러, 링커를 모두 내장하고 있으므로, 소스 파일에서 한 번에 실행 파일을 생성해 준다.

이렇게 생성된 실행 파일의 확장자는 .exe 가 된다.

## 변수

변수 이름 생성 규칙

1. 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성된다.

2. 변수의 이름은 숫자로 시작될 수 없다.

3. 변수의 이름 사이에는 공백을 포함할 수 없다.

4. 변수의 이름으로 C언어에서 미리 정의된 키워드(keyword)는 사용할 수 없다.

## 연산자의 우선순위

1. ++(후위 증가 연산자), --(후위 감소 연산자), (), [], . , ->

2. !, ~, +(양의 부호), -(음의 부호), ++(전위 증가 연산자), --(전위 감소 연산자), (타입 캐스트 연산자), *, &, sizeof

3. *, /, %

4. +, -

5. <<, >>

6. <, <=, >, >=

7. ==, !=

8. &

9. ^

10. |

11. &&

12. ||

13. ?:

14. =

15. , 

## 변수의 유효 범위

C언어에서는 변수의 선언 위치에 따라 해당 변수의 유효 범위, 메모리 반환 시기, 초기화 여부, 저장되는 장소 등이 변경된다.

C언어에서 변수는 위와 같은 특징들을 기준으로 다음과 같이 나눌 수 있다.

1. 지역 변수(local variable)

지역 변수란 '블록' 내에서 선언된 변수를 의미한다.

지역 변수는 변수가 선언된 블록에서만 유효하며, 블록이 종료되면 메모리에서 사라진다.

이런 지역 변수는 메모리 상 Stack 영역에 저장된다.

2. 전역 변수(global variable)

전역 변수란 함수의 외부에서 선언된 변수를 의미한다.

전역 변수는 프로그램의 어디서나 접근 가능하며 프로그램이 종료되면 메모리에서 사라진다.

이런 전역 변수는 메모리 상 Data 영역에 저장된다.

3. 정적 변수(static variable)

정적 변수란 static 키워드로 선언한 변수를 의미한다.

이런 정적 변수는 지역 변수와 전역 변수의 특징을 모두 가진다.

함수 내에서 선언된 정적 변수는 한 번만 초기화되고 프로그램이 종료되야 메모리에서 사라진다.

해당 함수 내에서만 접근할 수 있다.

4. 레지스터 변수(register variable)

지역 변수를 선언할 때 register 키워드를 붙여 선언한 변수를 의미한다.

이렇게 선언된 레지스터 변수는 CPU 레지스터 메모리에 저장되어 빠르게 접근할 수 있다.

## 메모리의 구조

1. Code 영역

작성한 코드, 실행할 프로그램의 코드가 저장되는 영역이다.

CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다.

2. Data 영역

전역 변수, Static 변수

프로그램의 시작과 함께 할당되며 프로그램 종료 시 소멸한다.

3. Stack 영역

지역 변수, 매개 변수

함수의 호출과 함께 할당되고 함수의 호출 완료시 소멸한다.

이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임이라고 한다.

스택 프레임 덕분에 함수의 호출이 끝난 후 해당 함수가 호출되기 전으로 돌아갈 수 있다.

메모리의 높은 주소에서 낮은 주소 방향으로 할당한다.

4. Heap 영역

동적 할당

사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.

메모리의 낮은 주소에서 높은 주소로 할당된다.

## 포인터 연산자

1. 주소 연산자(&)

주소 연산자는 변수의 이름 앞에 사용하며 해당 변수의 주소값을 반환한다.

2. 참조 연산자(*)

참조 연산자는 포인터의 이름이나 주소 앞에 사용하며 포인터가 가리키는 주소에 저장된 값을 반환한다.

## 인수 전달 방법

1. 값에 의한 전달(Call by Value)

값에 의한 전달 방법은 인수로 전달되는 변수가 가지고 있는 값을 함수 내의 매개변수에 복사하는 방식이다.

복사된 값으로 초기화된 매개 변수는 인수로 전달된 변수와 별개의 변수다.

따라서 함수 내 매개변수 조작은 인수로 정달되는 변수에 영향을 미치지 않는다.

2. 참조에 의한 전달(Call by Reference)

참조에 의한 전달 방법은 인수로 변수의 값을 전달 하는 것이 아닌 해당 변수의 주소값을 전달한다.

함수의 매개변수에 인수로 전달된 변수의 원래 주소값을 저장한다.


## 메모리의 동적 할당

데이터 영역과 스택 영역에 할당되는 메모리의 크기는 컴파일 타임에 미리 결정된다.

하지만 힙 영역의 크기는 프로그램이 실행되는 도중인 런 타임에 사용자가 직접 결정한다.

이렇게 런 타임에 메모리를 할당 받는 것을 메모리의 동적 할당이라고 한다.

- malloc() 함수

malloc() 함수는 프로그램이 실행 중일 때 사용자가 직접 힙 영역에 메모리를 할당할 수 있게 해준다.

malloc() 함수는 인수로 할당받고자 하는 메모리의 크기를 바이트 단위로 전달받는다.

- free() 함수

free() 함수는 힙 영역에 할당받은 메모리 공간을 다시 운영체제로 반환해 주는 함수다.

사용이 끝난 메모리를 해제하지 않아서 메모리가 부족해지는 현상을 메모리 누수(memory leak)가 생긴다.

- calloc() 함수

calloc() 함수는 malloc() 함수와 마찬가지로 힙 영역에 메모리를 동적으로 할당해주는 함수다.

malloc() 함수와 다른 점은 할당하고자 하는 메모리의 크기를 두 개의 인수로 나누어 전달받는 점이다.

calloc() 함수는 메모리를 할당받은 후에 해당 메모리의 모든 비트값을 전부 0으로 초기화해 준다.

- realloc() 함수

realloc() 함수는 이미 할당된 메모리의 크기를 바꾸어 재할당할 때 사용하는 함수다.

http://tcpschool.com/c/c_string_io


